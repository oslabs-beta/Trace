"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = start;
var _http = _interopRequireDefault(require("http"));
var _next = _interopRequireDefault(require("../next"));
var _log = require("../../build/output/log");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
async function start(serverOptions, port, hostname) {
    let requestHandler;
    const srv = _http.default.createServer((req, res)=>{
        return requestHandler(req, res);
    });
    const app = (0, _next).default({
        ...serverOptions,
        customServer: false,
        httpServer: srv
    });
    requestHandler = app.getRequestHandler();
    await new Promise((resolve, reject)=>{
        let retryCount = 0;
        srv.on('error', (err)=>{
            // This code catches EADDRINUSE error if the port is already in use
            if (err.code === 'EADDRINUSE' && serverOptions.allowRetry && port && retryCount < 10) {
                (0, _log).warn(`Port ${port} is in use, trying ${port + 1} instead.`);
                port += 1;
                retryCount += 1;
                srv.listen(port, hostname);
            } else {
                reject(err);
            }
        });
        srv.on('listening', ()=>resolve()
        );
        srv.listen(port, hostname);
    });
    // It's up to caller to run `app.prepare()`, so it can notify that the server
    // is listening before starting any intensive operations.
    const addr = srv.address();
    return {
        app,
        actualPort: addr && typeof addr === 'object' ? addr.port : port
    };
}

//# sourceMappingURL=start-server.js.map